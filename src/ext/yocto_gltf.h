///
/// # Yocto/glTF
///
/// Khronos GLTF loader and writer for Khronos glTF format. Supports
/// all the glTF spec and the Khronos extensions. All parsing and writing code
/// is autogenerated form the schema.
/// Supports glTF version 2.0 and the following extensions: `KHR_binary_glTF`,
/// `KHR_specular_glossiness`.
///
/// This library depends in yocto_math.h, JSON loading/writing depends on
/// json.hpp. Texture loading/saving depends on yocto_image.h. If the texture
/// loading/saving dependency is not desired, it can be disabled by defining
/// YGLTF_NO_IMAGE before including this file.
///
/// The library provides two interfaces. A low-level interface is a direct
/// C++ translation of the glTF schemas and should be used if one wants
/// complete control over the fromat or an application wants to have their
/// own scene code added. We also provide a high-level interface that is more
/// useful if an aplication needs direct access to shapes, textures and
/// animations and does not want to deal with all the intricacies of the format.
/// In particular all glTF buffers are resolved and normalized to standard C++
/// types. The high-level interface supports easy access to animation, skinning
/// and morphingd data.
///
/// Known limitations of the high-level interface are: (1) skinning matrices
/// are always in world space (waiting for the spec to be updated); (2)
/// spline based animation is not implemented properly yet (waiting for
/// official demo models).
///
/// ## Usage Of High-Level Interface
///
/// 1. load a group of scens with `load_scenes()`
/// 2. look at the `scene` data structures for access to individual elements
/// 3. to support animation, use `update_animated_transforms()`
/// 4. to support skinning, use `get_skin_transforms()`
/// 5. for morphing, use `compute_morphing_deformation()`
/// 6. can also manipulate the scene by adding missing data with `add_XXX()`
///    functions
/// 7. for rendering scenes, use `get_scene_cameras()` and
///    `get_scene_instances()` that avoid the need for explicirtly walking
///    the glTF node hierarchy
/// 8. use `save_scenes()` to write the data to disk
/// 9. use `convert_to_specgloss()` to convert materials to spec-gloss
///
/// ## Usage Of Low-Level Interface
///
/// 1. load a glTF data with `load_gltf()`; can load also buffer and image
///    data
/// 2. look at the `glTFXXX` data structures for access to individual elements
/// 3. use glTF back to disk with `save_gltf()`; can also save binary blobs
/// 4. conversion from low- to -high-level data structures with
///    `scenes_to_gltf()` and `gltf_to_scenes()`
///
///
/// ## Design Considerations
///
/// glTF is a *very* complex file format and was designed mainly with untyped
/// languages in mind. YOCTO_GLTF attempts to match the glTF low-level interface
/// to C++ as best as it can. Since the code is generated from the schema, we
/// follow glTF naming conventions and typing quite well. To simplify adoption
/// and keep the API relatively simple we use std::vector as arrays and use
/// pointers to reference to all glTF objects. While this makes it less effcient
/// than it might have been, glTF heavy use of optional values makes this
/// necessary. At the same time, we do not keep track of set/unset values
/// for basic types (int, float, bool) as a compromise for efficieny.
///
/// In the low level interface, glTF uses integer indices to access objects.
/// While writing code ourselves we found that we add signiicant problems
/// since we would use an index to access the wriong type of scene objects.
/// For this reasons, we use an explit index `glTFid<T>` that can only access
/// an object of type T. Internally this is just the same old glTF index. But
/// this can used to access the scene data with `scene::get<T>(index)`.
///
///
/// ## History
///
/// - v 0.22: conversion to spec gloss
/// - v 0.21: use reference interface for textures
/// - v 0.20: removal of buggy shape splitting function
/// - v 0.19: explicit paths for separate buffer saving
/// - v 0.18: add function to split meshes into single shapes
/// - v 0.17: add per-mesh buffer on write from scene
/// - v 0.16: add transforms under function calls
/// - v 0.15: remove exception from code and add explicit error handling
/// - v 0.14: texture have always 4 channels
/// - v 0.13: change variable names for compilation on gcc
/// - v 0.12: removed explicit root nodes
/// - v 0.11: added camera near/far to high-level interface
/// - v 0.10: added moprhing to high-level interface
/// - v 0.9: use yocto_math in the interface and remove inline compilation
/// - v 0.8: API changes to match to GLTF 2
/// - v 0.7: new codegen to match to GLTF 2 (changes imposed by changing spec)
/// - v 0.6: switch to .h/.cpp pair
/// - v 0.5: bug fixes and added checks for missing files
/// - v 0.4: internally use pointers for performance transaprency
/// - v 0.4: doxygen documentation
/// - v 0.3: load/write interface with exceptions
/// - v 0.2: doxygen comments
/// - v 0.1: bug fix when writing names
/// - v 0.0: initial release
///
namespace ygltf {}

//
// LICENSE:
//
// Copyright (c) 2016 -- 2017 Fabio Pellacini
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// LICENSE OF INCLUDED CODE
//
//
// base64.cpp and base64.h
//
// Copyright (C) 2004-2008 René Nyffenegger
//
// This source code is provided 'as-is', without any express or implied
// warranty. In no event will the author be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this source code must not be misrepresented; you must not
// claim that you wrote the original source code. If you use this source code
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original source code.
//
// 3. This notice may not be removed or altered from any source distribution.
//
// René Nyffenegger rene.nyffenegger@adp-gmbh.ch
//

#ifndef _YGLTF_H_
#define _YGLTF_H_

#include <array>
#include <cfloat>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "json.hpp"
#include "yocto_math.h"

// -----------------------------------------------------------------------------
// INTERFACE
// -----------------------------------------------------------------------------

///
/// Reading and writing glTF fileformat.
///
namespace ygltf {

// forward declaration
struct glTF;

// -----------------------------------------------------------------------------
// HIGH-LEVEL INTERFACE
// -----------------------------------------------------------------------------

///
/// Camera
///
struct camera {
    /// name
    std::string name = "";
    /// orthographic
    bool ortho = false;
    /// aspect ratio
    float aspect = 1;
    /// vertical fov (perspective) or size (orthographic)
    float yfov = 2 * std::atan(0.5f);
    /// near plane (0 for default)
    float near = 0;
    /// far plane (0 for default)
    float far = 0;
    /// focus distance (extension not implemented yet)
    float focus = 1;
    /// lens aperture (extension not implemented yet)
    float aperture = 0;
};

///
/// Texture
///
struct texture {
    /// name
    std::string name = "";
    /// path
    std::string path = "";
    /// 8-bit data
    ym::image4b ldr;
    /// float data
    ym::image4f hdr;

    /// get texture width
    int width() const {
        if (ldr) return ldr.width();
        if (hdr) return hdr.width();
        return 0;
    }
    /// get texture height
    int height() const {
        if (ldr) return ldr.height();
        if (hdr) return hdr.height();
        return 0;
    }
};

///
/// Texture wrap mode
///
enum struct texture_wrap {
    /// repeat
    repeat = 1,
    /// clamp
    clamp = 2,
    /// mirror
    mirror = 3,
};

///
/// Texture filter mode
///
enum struct texture_filter {
    /// linear
    linear = 1,
    /// nearest
    nearest = 2,
    /// linear mipmap linear
    linear_mipmap_linear = 3,
    /// nearest mipmap nearest
    nearest_mipmap_nearest = 4,
    /// linear mipmap nearest
    linear_mipmap_nearest = 5,
    /// nearest mipmap linear
    nearest_mipmap_linear = 6,
};

///
/// Texture information
///
struct texture_info {
    /// wrap mode for s coordinate
    texture_wrap wrap_s = texture_wrap::repeat;
    /// wrap mdoe for t coordinate
    texture_wrap wrap_t = texture_wrap::repeat;
    /// filter mode
    texture_filter filter_mag = texture_filter::linear;
    /// filter mode
    texture_filter filter_min = texture_filter::linear_mipmap_linear;

    /// texture strength (occlusion and normal)
    float scale = 1;

    /// check if it is default
    bool is_default() const {
        return wrap_s == texture_wrap::repeat &&
               wrap_t == texture_wrap::repeat &&
               filter_mag == texture_filter::linear &&
               filter_min == texture_filter::linear_mipmap_linear;
    }
};

///
/// Material PBR metallic roughness
///
struct material_metallic_rooughness {
    /// base color
    ym::vec3f base = {0, 0, 0};
    /// opacity
    float opacity = 1;
    /// metallic factor
    float metallic = 0;
    /// metallic roughness
    float roughness = 0;
    /// base texture (kb.x, kb.y, kb.z, op)
    texture* base_txt = nullptr;
    /// metallic-roughness texture (n/a, roughness, metallic, n/a)
    texture* metallic_txt = nullptr;
    /// texture information for base_txt
    texture_info* base_txt_info = nullptr;
    /// texture information for metallic_txt
    texture_info* metallic_txt_info = nullptr;

    /// cleanup
    ~material_metallic_rooughness() {
        if (base_txt_info) delete base_txt_info;
        if (metallic_txt_info) delete metallic_txt_info;
    }
};

///
/// Material PBR specular glossiness
///
struct material_specular_glossiness {
    /// diffuse color and opacity
    ym::vec3f diffuse = {0, 0, 0};
    /// opacity
    float opacity = 1;
    /// specular color (spec.x, spec.y, spec.z, opacity)
    ym::vec3f specular = {0, 0, 0};
    /// specular glossiness
    float glossiness = 1;
    /// diffuse texture (diff.x, diff.y, diff.z, opacity)
    texture* diffuse_txt = nullptr;
    /// specular-glossiness texture (spec.x, spec.y, spec.z, gloss)
    texture* specular_txt = nullptr;
    /// texture information for base_txt
    texture_info* diffuse_txt_info = nullptr;
    /// texture information for metallic_txt
    texture_info* specular_txt_info = nullptr;

    /// cleanup
    ~material_specular_glossiness() {
        if (diffuse_txt_info) delete diffuse_txt_info;
        if (specular_txt_info) delete specular_txt_info;
    }
};

///
/// Material
///
/// glTF 2.0 has two physically-based aterial models: pbrMetallicRoughness
/// and pbrSpecularGlossiness, the latter as an extension. Here we support both
/// by including which one is defined. While it would have been more appropriate
/// to convert them, this requires a rewrite of texture data which w prefer to
/// avoid.
///
struct material {
    /// name
    std::string name = "";

    // common properties --------------------
    /// emission color
    ym::vec3f emission = {0, 0, 0};
    /// emissive texture reference
    texture* emission_txt = nullptr;
    /// texture information for normal_txt
    texture_info* emission_txt_info = nullptr;

    // reflectance --------------------------
    /// metallic roughnesss
    material_metallic_rooughness* metallic_roughness = nullptr;
    /// specular glossiness
    material_specular_glossiness* specular_glossiness = nullptr;

    // other textures -----------------------
    /// occlusion texture
    texture* occlusion_txt = nullptr;
    /// normal texture
    texture* normal_txt = nullptr;
    /// texture information for collusion_txt
    texture_info* occlusion_txt_info = nullptr;
    /// texture information for normal_txt
    texture_info* normal_txt_info = nullptr;

    // other Parameters ---------------------
    /// double sided
    bool double_sided = true;

    /// cleanup
    ~material() {
        if (emission_txt_info) delete emission_txt_info;
        if (normal_txt_info) delete normal_txt_info;
        if (occlusion_txt_info) delete occlusion_txt_info;
        if (metallic_roughness) delete metallic_roughness;
        if (specular_glossiness) delete specular_glossiness;
    }
};

///
/// Morph information for shapes
///
struct shape_morph {
    /// morph position
    std::vector<ym::vec3f> pos;
    /// morph normal
    std::vector<ym::vec3f> norm;
    /// morph tangent
    std::vector<ym::vec3f> tangsp;
    /// default weight (the same for each shape in a mesh)
    float weight = 0;
};

///
/// Primitives
///

struct shape {
    /// name of the mesh that enclosed it
    std::string name = "";
    /// material reference
    material* mat = nullptr;

    /// vertex position
    std::vector<ym::vec3f> pos;
    /// vertex normal
    std::vector<ym::vec3f> norm;
    /// vertex texcoord
    std::vector<ym::vec2f> texcoord;
    /// vertex additional texcoord
    std::vector<ym::vec2f> texcoord1;
    /// vertex color
    std::vector<ym::vec4f> color;
    /// vertex radius
    std::vector<float> radius;
    /// vertex tangent space
    std::vector<ym::vec4f> tangsp;

    /// vertex skinning weights
    std::vector<ym::vec4f> skin_weights;
    /// vertex skinning joint indices
    std::vector<ym::vec4i> skin_joints;

    /// point elements
    std::vector<int> points;
    /// line elements
    std::vector<ym::vec2i> lines;
    /// triangle elements
    std::vector<ym::vec3i> triangles;

    /// morph targets
    std::vector<shape_morph*> morph_targets;

    /// cleanup
    ~shape() {
        for (auto e : morph_targets)
            if (e) delete e;
    }
};

///
/// Gltf mesh.
///
struct mesh {
    /// name
    std::string name = "";
    /// path (only used when writing files on disk with glTF)
    std::string path = "";
    /// primitives references
    std::vector<shape*> shapes;

    /// cleanup
    ~mesh();
};

// forward declaration
struct skin;

///
/// Node in the hierarchy.
///
struct node {
    /// name
    std::string name = "";
    /// camera reference
    camera* cam = nullptr;
    /// mesh reference
    mesh* msh = nullptr;
    /// mesh reference
    skin* skn = nullptr;
    /// children
    std::vector<node*> children;

    /// A floating-point 4x4 transformation matrix stored in column-major order.
    ym::mat4f matrix = ym::identity_mat4f;
    /// The node's unit quaternion rotation in the order (x, y, z, w), where w
    /// is the scalar.
    ym::quat4f rotation = {0, 0, 0, 1};
    /// The node's non-uniform scale.
    ym::vec3f scale = {1, 1, 1};
    /// The node's translation.
    ym::vec3f translation = {0, 0, 0};
    /// morph target weights
    std::vector<float> morph_weights;

    // computed properties ---------------
    /// parent node (computed during update_node_hierarchy())
    node* parent = nullptr;

    // computed properties ---------------
    /// transform (computed during update_transforms())
    ym::mat4f xform() const { return _xform; }
    /// local transform (computed during update_transforms())
    ym::mat4f local_xform() const { return _local_xform; }
    /// skin transform (computed during update_transforms())
    ym::mat4f skin_xform() const { return _skin_xform; }

    // cached properties -----------------
    // do not access directly: this is likely to change
    /// transform (computed during update_transforms())
    ym::mat4f _xform = ym::identity_mat4f;
    /// local transform (computed during update_transforms())
    ym::mat4f _local_xform = ym::identity_mat4f;
    /// skin transform (computed during update_transforms())
    ym::mat4f _skin_xform = ym::identity_mat4f;
};

///
/// Animation Interpolation
///
enum struct animation_interpolation {
    /// linear
    linear = 0,
    /// step function
    step = 1,
    /// catmull-rom spline
    catmull_rom = 2,
    /// cubic bezier spline
    cubic = 3,
};

///
/// Keyframe data.
///
struct animation {
    /// Interpolation
    animation_interpolation interp = animation_interpolation::step;
    /// Target nodes
    std::vector<node*> nodes;
    /// Times
    std::vector<float> time;
    /// Translation
    std::vector<ym::vec3f> translation;
    /// Rotation
    std::vector<ym::quat4f> rotation;
    /// Scale
    std::vector<ym::vec3f> scale;
    /// Weights for morphing
    std::vector<std::vector<float>> morph_weights;
};

///
/// Animation
///
struct animation_group {
    /// Name
    std::string name;
    /// path (only used when writing files on disk with glTF)
    std::string path = "";
    /// Times
    std::vector<animation*> animations;

    /// cleanup
    ~animation_group();
};

///
/// Skin
///
struct skin {
    /// name
    std::string name = "";
    /// path (only used when writing files on disk with glTF)
    std::string path = "";
    /// inverse bind matrix
    std::vector<ym::mat4f> pose_matrices;
    /// joints
    std::vector<node*> joints;
    /// skeleton root node
    node* root = nullptr;
};

///
/// Gltf scene
///
struct scene {
    /// name
    std::string name = "";
    /// instances
    std::vector<node*> nodes;
};

///
/// Gltf model. Objects are shared between scenes.
/// Scenes and nodes are missing for mesh-only assets.
///
struct scene_group {
    /// default scene (null if not present)
    scene* default_scene = nullptr;
    /// cameras
    std::vector<camera*> cameras;
    /// materials
    std::vector<material*> materials;
    /// textures
    std::vector<texture*> textures;
    /// meshes
    std::vector<mesh*> meshes;
    /// scenes
    std::vector<scene*> scenes;
    /// nodes
    std::vector<node*> nodes;
    /// nodes
    std::vector<animation_group*> animations;
    /// skins
    std::vector<skin*> skins;

    /// cleanup
    ~scene_group();
};

///
/// Load scene
///
/// - Parameters:
///     - filename: filename
///     - load_textures: whether to load textures (default to false)
///     - skip_missing: whether to skip missing buffers and textures
/// - Returns:
///     - scene (nullptr on error)
///
scene_group* load_scenes(
    const std::string& filename, bool load_textures, bool skip_missing = true);

///
/// Save scene
///
/// - Parameters:
///     - filename: filename
///     - buffer_uri: name of the main buffer
///     - scn: scene data to save
///     - save_textures: whether to save textures (default to false)
///     - separate_buffers: save separate buffers for each mesh
///
void save_scenes(const std::string& filename, const std::string& buffer_uri,
    const scene_group* scn, bool save_textures, bool separate_buffers = false);

///
/// Update node hierarchy
///
void update_node_hierarchy(scene_group* scn);

///
/// Update node trasforms
///
void update_transforms(scene_group* scn);

//
// Update animated node
//
void update_animated_transforms(scene_group* scns, float time);

///
/// Get a list of nodes with meshes
///
std::vector<node*> get_mesh_nodes(const scene* scn);

///
/// Get a list of nodes with cameras
///
std::vector<node*> get_camera_nodes(const scene* scn);

///
/// Animation times
///
ym::vec2f get_animation_bounds(const scene_group* scn);

///
/// Skin transforms (local-to-object) from the node transform that instances the
/// skin
///
std::vector<ym::mat4f> get_skin_transforms(
    const skin* sk, const ym::mat4f& xform);

///
/// Compute shape morphing
///
void compute_morphing_deformation(const shape* shp,
    const std::vector<float>& weights, std::vector<ym::vec3f>& pos,
    std::vector<ym::vec3f>& norm, std::vector<ym::vec4f>& tangsp);

///
/// Computes a scene bounding box
///
ym::bbox3f compute_scene_bounds(const scene_group* scn);

///
/// Add missing data to the scene.
///
void add_normals(scene_group* scn);

///
/// Add missing data to the scene.
///
void add_radius(scene_group* scn, float radius);

///
/// Add missing data to the scene.
///
void add_tangent_space(scene_group* scn);

///
/// Add missing data to the scene.
///
void add_nodes(scene_group* scn);

///
/// Add missing data to the scene.
///
void add_scene(scene_group* scn);

///
/// Add missing data to the scene.
///
void add_texture_data(scene_group* scn);

///
/// Add missing data to the scene.
///
void add_names(scene_group* scn);

///
/// Add a default camera that views the entire scene.
///
void add_default_cameras(scene_group* scn);

///
/// Set unique path names for outputting separate buffers
///
void add_unique_path_names(scene_group* scns, const std::string& buffer_uri);

///
/// Convert materials to spec gloss
///
void add_spec_gloss(scene_group* scns);

// -----------------------------------------------------------------------------
// LOW-LEVEL INTERFACE
// -----------------------------------------------------------------------------

///
/// Json alias
///
using json = nlohmann::json;

///
/// Shader data
///
using shader_data = std::string;

///
/// Generic buffer data.
///
using buffer_data = std::vector<unsigned char>;

///
/// Generic image data.
///
struct image_data {
    /// Width
    int width = 0;
    /// Height
    int height = 0;
    /// Number of Channels
    int ncomp = 0;
    /// Buffer data for 8-bit images
    std::vector<uint8_t> datab;
    /// Buffer data for float images
    std::vector<float> dataf;
};

///
/// Extensions
///
using extension_t = std::map<std::string, json>;

///
/// Extras
///
using extras_t = json;

///
/// glTFid
///
template <typename T>
struct glTFid {
    /// defaoult constructor to an invalid id
    constexpr glTFid() : _id(-1) {}
    /// explicit conversion from integer
    constexpr explicit glTFid(int id) : _id(id) {}
    /// explicit convcersion to integer
    constexpr explicit operator int() const { return _id; }

    /// check if it is valid
    bool is_valid() const { return _id >= 0; }
    /// check if it is valid
    explicit operator bool() const { return _id >= 0; }

   private:
    // id
    int _id = -1;
};

// #codegen begin type
// forward decalration
struct glTFProperty;
struct glTFChildOfRootProperty;
struct glTFAccessorSparseIndices;
struct glTFAccessorSparseValues;
struct glTFAccessorSparse;
struct glTFAccessor;
struct glTFAnimationChannelTarget;
struct glTFAnimationChannel;
struct glTFAnimationSampler;
struct glTFAnimation;
struct glTFAsset;
struct glTFBuffer;
struct glTFBufferView;
struct glTFCameraOrthographic;
struct glTFCameraPerspective;
struct glTFCamera;
struct glTFImage;
struct glTFTextureInfo;
struct glTFTexture;
struct glTFMaterialNormalTextureInfo;
struct glTFMaterialOcclusionTextureInfo;
struct glTFMaterialPbrMetallicRoughness;
struct glTFMaterialPbrSpecularGlossiness;
struct glTFMaterial;
struct glTFMeshPrimitive;
struct glTFMesh;
struct glTFNode;
struct glTFSampler;
struct glTFScene;
struct glTFSkin;
struct glTF;

///
/// No documentation in schema.
///
struct glTFProperty {
    /// No documentation in schema.
    extension_t extensions = {};
    /// No documentation in schema.
    extras_t extras = {};
};

///
/// No documentation in schema.
///
struct glTFChildOfRootProperty : glTFProperty {
    /// The user-defined name of this object.
    std::string name = "";
};

///
/// Enum values for glTFAccessorSparseIndices::componentType.
///
enum struct glTFAccessorSparseIndicesComponentType {
    /// not set
    NotSet = -1,
    /// UnsignedByte
    UnsignedByte = 5121,
    /// UnsignedShort
    UnsignedShort = 5123,
    /// UnsignedInt
    UnsignedInt = 5125,
};

///
/// Indices of those attributes that deviate from their initialization value.
///
struct glTFAccessorSparseIndices : glTFProperty {
    /// The index of the bufferView with sparse indices. Referenced bufferView
    /// can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]
    glTFid<glTFBufferView> bufferView = {};
    /// The offset relative to the start of the bufferView in bytes. Must be
    /// aligned.
    int byteOffset = 0;
    /// The indices data type. [required]
    glTFAccessorSparseIndicesComponentType componentType =
        glTFAccessorSparseIndicesComponentType::NotSet;
};

///
/// Array of size `accessor.sparse.count` times number of components storing the
/// displaced accessor attributes pointed by `accessor.sparse.indices`.
///
struct glTFAccessorSparseValues : glTFProperty {
    /// The index of the bufferView with sparse values. Referenced bufferView
    /// can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target. [required]
    glTFid<glTFBufferView> bufferView = {};
    /// The offset relative to the start of the bufferView in bytes. Must be
    /// aligned.
    int byteOffset = 0;
};

///
/// Sparse storage of attributes that deviate from their initialization value.
///
struct glTFAccessorSparse : glTFProperty {
    /// Number of entries stored in the sparse array. [required]
    int count = 0;
    /// Index array of size `count` that points to those accessor attributes
    /// that deviate from their initialization value. Indices must strictly
    /// increase. [required]
    glTFAccessorSparseIndices* indices = nullptr;
    /// Array of size `count` times number of components, storing the displaced
    /// accessor attributes pointed by `indices`. Substituted values must have
    /// the same `componentType` and number of components as the base accessor.
    /// [required]
    glTFAccessorSparseValues* values = nullptr;

    /// destructor
    ~glTFAccessorSparse() {
        if (indices) delete indices;
        if (values) delete values;
    }
};

///
/// Enum values for glTFAccessor::componentType.
///
enum struct glTFAccessorComponentType {
    /// not set
    NotSet = -1,
    /// Byte
    Byte = 5120,
    /// UnsignedByte
    UnsignedByte = 5121,
    /// Short
    Short = 5122,
    /// UnsignedShort
    UnsignedShort = 5123,
    /// UnsignedInt
    UnsignedInt = 5125,
    /// Float
    Float = 5126,
};

///
/// Values for glTFAccessor::type.
///
enum struct glTFAccessorType {
    /// not set
    NotSet = -1,
    /// Scalar
    Scalar = 0,
    /// Vec2
    Vec2 = 1,
    /// Vec3
    Vec3 = 2,
    /// Vec4
    Vec4 = 3,
    /// Mat2
    Mat2 = 4,
    /// Mat3
    Mat3 = 5,
    /// Mat4
    Mat4 = 6,
};

///
/// A typed view into a bufferView.  A bufferView contains raw binary data.  An
/// accessor provides a typed view into a bufferView or a subset of a bufferView
/// similar to how WebGL's `vertexAttribPointer()` defines an attribute in a
/// buffer.
///
struct glTFAccessor : glTFChildOfRootProperty {
    /// The index of the bufferView.
    glTFid<glTFBufferView> bufferView = {};
    /// The offset relative to the start of the bufferView in bytes.
    int byteOffset = 0;
    /// The datatype of components in the attribute. [required]
    glTFAccessorComponentType componentType = glTFAccessorComponentType::NotSet;
    /// The number of attributes referenced by this accessor. [required]
    int count = 0;
    /// Maximum value of each component in this attribute.
    std::vector<float> max = {};
    /// Minimum value of each component in this attribute.
    std::vector<float> min = {};
    /// Specifies whether integer data values should be normalized.
    bool normalized = false;
    /// Sparse storage of attributes that deviate from their initialization
    /// value.
    glTFAccessorSparse* sparse = nullptr;
    /// Specifies if the attribute is a scalar, vector, or matrix. [required]
    glTFAccessorType type = glTFAccessorType::NotSet;

    /// destructor
    ~glTFAccessor() {
        if (sparse) delete sparse;
    }
};

///
/// Values for glTFAnimationChannelTarget::path.
///
enum struct glTFAnimationChannelTargetPath {
    /// not set
    NotSet = -1,
    /// Translation
    Translation = 0,
    /// Rotation
    Rotation = 1,
    /// Scale
    Scale = 2,
    /// Weights
    Weights = 3,
};

///
/// The index of the node and TRS property that an animation channel targets.
///
struct glTFAnimationChannelTarget : glTFProperty {
    /// The index of the node to target. [required]
    glTFid<glTFNode> node = {};
    /// The name of the node's TRS property to modify, or the "weights" of the
    /// Morph Targets it instantiates. [required]
    glTFAnimationChannelTargetPath path =
        glTFAnimationChannelTargetPath::NotSet;
};

///
/// Targets an animation's sampler at a node's property.
///
struct glTFAnimationChannel : glTFProperty {
    /// The index of a sampler in this animation used to compute the value for
    /// the target. [required]
    glTFid<glTFAnimationSampler> sampler = {};
    /// The index of the node and TRS property to target. [required]
    glTFAnimationChannelTarget* target = nullptr;

    /// destructor
    ~glTFAnimationChannel() {
        if (target) delete target;
    }
};

///
/// Values for glTFAnimationSampler::interpolation.
///
enum struct glTFAnimationSamplerInterpolation {
    /// not set
    NotSet = -1,
    /// Linear
    Linear = 0,
    /// Step
    Step = 1,
    /// Catmullromspline
    Catmullromspline = 2,
    /// Cubicspline
    Cubicspline = 3,
};

///
/// Combines input and output accessors with an interpolation algorithm to
/// define a keyframe graph (but not its target).
///
struct glTFAnimationSampler : glTFProperty {
    /// The index of an accessor containing keyframe input values, e.g., time.
    /// [required]
    glTFid<glTFAccessor> input = {};
    /// Interpolation algorithm.
    glTFAnimationSamplerInterpolation interpolation =
        glTFAnimationSamplerInterpolation::Linear;
    /// The index of an accessor, containing keyframe output values. [required]
    glTFid<glTFAccessor> output = {};
};

///
/// A keyframe animation.
///
struct glTFAnimation : glTFChildOfRootProperty {
    /// An array of channels, each of which targets an animation's sampler at a
    /// node's property. Different channels of the same animation can't have
    /// equal targets. [required]
    std::vector<glTFAnimationChannel*> channels = {};
    /// An array of samplers that combines input and output accessors with an
    /// interpolation algorithm to define a keyframe graph (but not its target).
    /// [required]
    std::vector<glTFAnimationSampler*> samplers = {};

    // access functions -------------
    /// typed access for channels
    glTFAnimationChannel* get(const glTFid<glTFAnimationChannel>& id) const {
        if (!id) return nullptr;
        return channels.at((int)id);
    }
    /// typed access for samplers
    glTFAnimationSampler* get(const glTFid<glTFAnimationSampler>& id) const {
        if (!id) return nullptr;
        return samplers.at((int)id);
    }

    /// destructor
    ~glTFAnimation() {
        for (auto e : channels)
            if (e) delete e;
        for (auto e : samplers)
            if (e) delete e;
    }
};

///
/// Metadata about the glTF asset.
///
struct glTFAsset : glTFProperty {
    /// A copyright message suitable for display to credit the content creator.
    std::string copyright = "";
    /// Tool that generated this glTF model.  Useful for debugging.
    std::string generator = "";
    /// The minimum glTF version that this asset targets.
    std::string minVersion = "";
    /// The glTF version that this asset targets. [required]
    std::string version = "";
};

///
/// A buffer points to binary geometry, animation, or skins.
///
struct glTFBuffer : glTFChildOfRootProperty {
    /// The length of the buffer in bytes. [required]
    int byteLength = 0;
    /// The uri of the buffer.
    std::string uri = "";

    // extra vars -------------------
    /// Buffer data if loaded.
    buffer_data data = {};
};

///
/// Enum values for glTFBufferView::target.
///
enum struct glTFBufferViewTarget {
    /// not set
    NotSet = -1,
    /// ArrayBuffer
    ArrayBuffer = 34962,
    /// ElementArrayBuffer
    ElementArrayBuffer = 34963,
};

///
/// A view into a buffer generally representing a subset of the buffer.
///
struct glTFBufferView : glTFChildOfRootProperty {
    /// The index of the buffer. [required]
    glTFid<glTFBuffer> buffer = {};
    /// The length of the bufferView in bytes. [required]
    int byteLength = 0;
    /// The offset into the buffer in bytes.
    int byteOffset = 0;
    /// The stride, in bytes.
    int byteStride = 0;
    /// The target that the GPU buffer should be bound to.
    glTFBufferViewTarget target = glTFBufferViewTarget::NotSet;
};

///
/// An orthographic camera containing properties to create an orthographic
/// projection matrix.
///
struct glTFCameraOrthographic : glTFProperty {
    /// The floating-point horizontal magnification of the view. [required]
    float xmag = 0;
    /// The floating-point vertical magnification of the view. [required]
    float ymag = 0;
    /// The floating-point distance to the far clipping plane. `zfar` must be
    /// greater than `znear`. [required]
    float zfar = 0;
    /// The floating-point distance to the near clipping plane. [required]
    float znear = 0;
};

///
/// A perspective camera containing properties to create a perspective
/// projection matrix.
///
struct glTFCameraPerspective : glTFProperty {
    /// The floating-point aspect ratio of the field of view.
    float aspectRatio = 0;
    /// The floating-point vertical field of view in radians. [required]
    float yfov = 0;
    /// The floating-point distance to the far clipping plane.
    float zfar = 0;
    /// The floating-point distance to the near clipping plane. [required]
    float znear = 0;
};

///
/// Values for glTFCamera::type.
///
enum struct glTFCameraType {
    /// not set
    NotSet = -1,
    /// Perspective
    Perspective = 0,
    /// Orthographic
    Orthographic = 1,
};

///
/// A camera's projection.  A node can reference a camera to apply a transform
/// to place the camera in the scene.
///
struct glTFCamera : glTFChildOfRootProperty {
    /// An orthographic camera containing properties to create an orthographic
    /// projection matrix.
    glTFCameraOrthographic* orthographic = nullptr;
    /// A perspective camera containing properties to create a perspective
    /// projection matrix.
    glTFCameraPerspective* perspective = nullptr;
    /// Specifies if the camera uses a perspective or orthographic projection.
    /// [required]
    glTFCameraType type = glTFCameraType::NotSet;

    /// destructor
    ~glTFCamera() {
        if (orthographic) delete orthographic;
        if (perspective) delete perspective;
    }
};

///
/// Values for glTFImage::mimeType.
///
enum struct glTFImageMimeType {
    /// not set
    NotSet = -1,
    /// ImageJpeg
    ImageJpeg = 0,
    /// ImagePng
    ImagePng = 1,
};

///
/// Image data used to create a texture. Image can be referenced by URI or
/// `bufferView` index. `mimeType` is required in the latter case.
///
struct glTFImage : glTFChildOfRootProperty {
    /// The index of the bufferView that contains the image. Use this instead of
    /// the image's uri property.
    glTFid<glTFBufferView> bufferView = {};
    /// The image's MIME type.
    glTFImageMimeType mimeType = glTFImageMimeType::NotSet;
    /// The uri of the image.
    std::string uri = "";

    // extra vars -------------------
    /// Image data if loaded.
    image_data data = {};
};

///
/// Reference to a texture.
///
struct glTFTextureInfo : glTFProperty {
    /// The index of the texture. [required]
    glTFid<glTFTexture> index = {};
    /// The set index of texture's TEXCOORD attribute used for texture
    /// coordinate mapping.
    int texCoord = 0;
};

///
/// A texture and its sampler.
///
struct glTFTexture : glTFChildOfRootProperty {
    /// The index of the sampler used by this texture. When undefined, a sampler
    /// with repeat wrapping and auto filtering should be used.
    glTFid<glTFSampler> sampler = {};
    /// The index of the image used by this texture.
    glTFid<glTFImage> source = {};
};

///
/// No documentation in schema.
///
struct glTFMaterialNormalTextureInfo : glTFTextureInfo {
    /// The scalar multiplier applied to each normal vector of the normal
    /// texture.
    float scale = 1;
};

///
/// No documentation in schema.
///
struct glTFMaterialOcclusionTextureInfo : glTFTextureInfo {
    /// A scalar multiplier controlling the amount of occlusion applied.
    float strength = 1;
};

///
/// A set of parameter values that are used to define the metallic-roughness
/// material model from Physically-Based Rendering (PBR) methodology.
///
struct glTFMaterialPbrMetallicRoughness : glTFProperty {
    /// The material's base color factor.
    ym::vec4f baseColorFactor = {1, 1, 1, 1};
    /// The base color texture.
    glTFTextureInfo* baseColorTexture = nullptr;
    /// The metalness of the material.
    float metallicFactor = 1;
    /// The metallic-roughness texture.
    glTFTextureInfo* metallicRoughnessTexture = nullptr;
    /// The roughness of the material.
    float roughnessFactor = 1;

    /// destructor
    ~glTFMaterialPbrMetallicRoughness() {
        if (baseColorTexture) delete baseColorTexture;
        if (metallicRoughnessTexture) delete metallicRoughnessTexture;
    }
};

///
/// glTF extension that defines the specular-glossiness material model from
/// Physically-Based Rendering (PBR) methodology.
///
struct glTFMaterialPbrSpecularGlossiness : glTFProperty {
    /// The reflected diffuse factor of the material.
    ym::vec4f diffuseFactor = {1, 1, 1, 1};
    /// The diffuse texture.
    glTFTextureInfo* diffuseTexture = nullptr;
    /// The glossiness or smoothness of the material.
    float glossinessFactor = 1;
    /// The specular RGB color of the material.
    ym::vec3f specularFactor = {1, 1, 1};
    /// The specular-glossiness texture.
    glTFTextureInfo* specularGlossinessTexture = nullptr;

    /// destructor
    ~glTFMaterialPbrSpecularGlossiness() {
        if (diffuseTexture) delete diffuseTexture;
        if (specularGlossinessTexture) delete specularGlossinessTexture;
    }
};

///
/// Values for glTFMaterial::alphaMode.
///
enum struct glTFMaterialAlphaMode {
    /// not set
    NotSet = -1,
    /// Opaque
    Opaque = 0,
    /// Mask
    Mask = 1,
    /// Blend
    Blend = 2,
};

///
/// The material appearance of a primitive.
///
struct glTFMaterial : glTFChildOfRootProperty {
    /// The alpha cutoff value of the material.
    float alphaCutoff = 0.5;
    /// The alpha rendering mode of the material.
    glTFMaterialAlphaMode alphaMode = glTFMaterialAlphaMode::Opaque;
    /// Specifies whether the material is double sided.
    bool doubleSided = false;
    /// The emissive color of the material.
    ym::vec3f emissiveFactor = {0, 0, 0};
    /// The emissive map texture.
    glTFTextureInfo* emissiveTexture = nullptr;
    /// The normal map texture.
    glTFMaterialNormalTextureInfo* normalTexture = nullptr;
    /// The occlusion map texture.
    glTFMaterialOcclusionTextureInfo* occlusionTexture = nullptr;
    /// A set of parameter values that are used to define the metallic-roughness
    /// material model from Physically-Based Rendering (PBR) methodology. When
    /// not specified, all the default values of `pbrMetallicRoughness` apply.
    glTFMaterialPbrMetallicRoughness* pbrMetallicRoughness = nullptr;
    /// A set of parameter values that are used to define the
    /// specular-glossiness material model from Physically-Based Rendering (PBR)
    /// methodology. When not specified, all the default values of
    /// `pbrMetallicRoughness` apply.
    glTFMaterialPbrSpecularGlossiness* pbrSpecularGlossiness = nullptr;

    /// destructor
    ~glTFMaterial() {
        if (emissiveTexture) delete emissiveTexture;
        if (normalTexture) delete normalTexture;
        if (occlusionTexture) delete occlusionTexture;
        if (pbrMetallicRoughness) delete pbrMetallicRoughness;
        if (pbrSpecularGlossiness) delete pbrSpecularGlossiness;
    }
};

///
/// Enum values for glTFMeshPrimitive::mode.
///
enum struct glTFMeshPrimitiveMode {
    /// not set
    NotSet = -1,
    /// Points
    Points = 0,
    /// Lines
    Lines = 1,
    /// LineLoop
    LineLoop = 2,
    /// LineStrip
    LineStrip = 3,
    /// Triangles
    Triangles = 4,
    /// TriangleStrip
    TriangleStrip = 5,
    /// TriangleFan
    TriangleFan = 6,
};

///
/// Geometry to be rendered with the given material.
///
struct glTFMeshPrimitive : glTFProperty {
    /// A dictionary object, where each key corresponds to mesh attribute
    /// semantic and each value is the index of the accessor containing
    /// attribute's data. [required]
    std::map<std::string, glTFid<glTFAccessor>> attributes = {};
    /// The index of the accessor that contains the indices.
    glTFid<glTFAccessor> indices = {};
    /// The index of the material to apply to this primitive when rendering.
    glTFid<glTFMaterial> material = {};
    /// The type of primitives to render.
    glTFMeshPrimitiveMode mode = glTFMeshPrimitiveMode::Triangles;
    /// An array of Morph Targets, each  Morph Target is a dictionary mapping
    /// attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their
    /// deviations in the Morph Target.
    std::vector<std::map<std::string, glTFid<glTFAccessor>>> targets = {};
};

///
/// A set of primitives to be rendered.  A node can contain one mesh.  A node's
/// transform places the mesh in the scene.
///
struct glTFMesh : glTFChildOfRootProperty {
    /// An array of primitives, each defining geometry to be rendered with a
    /// material. [required]
    std::vector<glTFMeshPrimitive*> primitives = {};
    /// Array of weights to be applied to the Morph Targets.
    std::vector<float> weights = {};

    /// destructor
    ~glTFMesh() {
        for (auto e : primitives)
            if (e) delete e;
    }
};

///
/// A node in the node hierarchy.  When the node contains `skin`, all
/// `mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A
/// node can have either a `matrix` or any combination of
/// `translation`/`rotation`/`scale` (TRS) properties. TRS properties are
/// converted to matrices and postmultiplied in the `T * R * S` order to compose
/// the transformation matrix; first the scale is applied to the vertices, then
/// the rotation, and then the translation. If none are provided, the transform
/// is the identity. When a node is targeted for animation (referenced by an
/// animation.channel.target), only TRS properties may be present; `matrix` will
/// not be present.
///
struct glTFNode : glTFChildOfRootProperty {
    /// The index of the camera referenced by this node.
    glTFid<glTFCamera> camera = {};
    /// The indices of this node's children.
    std::vector<glTFid<glTFNode>> children = {};
    /// A floating-point 4x4 transformation matrix stored in column-major order.
    ym::mat4f matrix = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
    /// The index of the mesh in this node.
    glTFid<glTFMesh> mesh = {};
    /// The node's unit quaternion rotation in the order (x, y, z, w), where w
    /// is the scalar.
    ym::quat4f rotation = {0, 0, 0, 1};
    /// The node's non-uniform scale.
    ym::vec3f scale = {1, 1, 1};
    /// The index of the skin referenced by this node.
    glTFid<glTFSkin> skin = {};
    /// The node's translation.
    ym::vec3f translation = {0, 0, 0};
    /// The weights of the instantiated Morph Target. Number of elements must
    /// match number of Morph Targets of used mesh.
    std::vector<float> weights = {};
};

///
/// Enum values for glTFSampler::magFilter.
///
enum struct glTFSamplerMagFilter {
    /// not set
    NotSet = -1,
    /// Nearest
    Nearest = 9728,
    /// Linear
    Linear = 9729,
};

///
/// Enum values for glTFSampler::minFilter.
///
enum struct glTFSamplerMinFilter {
    /// not set
    NotSet = -1,
    /// Nearest
    Nearest = 9728,
    /// Linear
    Linear = 9729,
    /// NearestMipmapNearest
    NearestMipmapNearest = 9984,
    /// LinearMipmapNearest
    LinearMipmapNearest = 9985,
    /// NearestMipmapLinear
    NearestMipmapLinear = 9986,
    /// LinearMipmapLinear
    LinearMipmapLinear = 9987,
};

///
/// Enum values for glTFSampler::wrapS.
///
enum struct glTFSamplerWrapS {
    /// not set
    NotSet = -1,
    /// ClampToEdge
    ClampToEdge = 33071,
    /// MirroredRepeat
    MirroredRepeat = 33648,
    /// Repeat
    Repeat = 10497,
};

///
/// Enum values for glTFSampler::wrapT.
///
enum struct glTFSamplerWrapT {
    /// not set
    NotSet = -1,
    /// ClampToEdge
    ClampToEdge = 33071,
    /// MirroredRepeat
    MirroredRepeat = 33648,
    /// Repeat
    Repeat = 10497,
};

///
/// Texture sampler properties for filtering and wrapping modes.
///
struct glTFSampler : glTFChildOfRootProperty {
    /// Magnification filter.
    glTFSamplerMagFilter magFilter = glTFSamplerMagFilter::NotSet;
    /// Minification filter.
    glTFSamplerMinFilter minFilter = glTFSamplerMinFilter::NotSet;
    /// s wrapping mode.
    glTFSamplerWrapS wrapS = glTFSamplerWrapS::Repeat;
    /// t wrapping mode.
    glTFSamplerWrapT wrapT = glTFSamplerWrapT::Repeat;
};

///
/// The root nodes of a scene.
///
struct glTFScene : glTFChildOfRootProperty {
    /// The indices of each root node.
    std::vector<glTFid<glTFNode>> nodes = {};
};

///
/// Joints and matrices defining a skin.
///
struct glTFSkin : glTFChildOfRootProperty {
    /// The index of the accessor containing the floating-point 4x4 inverse-bind
    /// matrices.  The default is that each matrix is a 4x4 identity matrix,
    /// which implies that inverse-bind matrices were pre-applied.
    glTFid<glTFAccessor> inverseBindMatrices = {};
    /// Indices of skeleton nodes, used as joints in this skin. [required]
    std::vector<glTFid<glTFNode>> joints = {};
    /// The index of the node used as a skeleton root. When undefined, joints
    /// transforms resolve to scene root.
    glTFid<glTFNode> skeleton = {};
};

///
/// The root object for a glTF asset.
///
struct glTF : glTFProperty {
    /// An array of accessors.
    std::vector<glTFAccessor*> accessors = {};
    /// An array of keyframe animations.
    std::vector<glTFAnimation*> animations = {};
    /// Metadata about the glTF asset. [required]
    glTFAsset* asset = nullptr;
    /// An array of bufferViews.
    std::vector<glTFBufferView*> bufferViews = {};
    /// An array of buffers.
    std::vector<glTFBuffer*> buffers = {};
    /// An array of cameras.
    std::vector<glTFCamera*> cameras = {};
    /// Names of glTF extensions required to properly load this asset.
    std::vector<std::string> extensionsRequired = {};
    /// Names of glTF extensions used somewhere in this asset.
    std::vector<std::string> extensionsUsed = {};
    /// An array of images.
    std::vector<glTFImage*> images = {};
    /// An array of materials.
    std::vector<glTFMaterial*> materials = {};
    /// An array of meshes.
    std::vector<glTFMesh*> meshes = {};
    /// An array of nodes.
    std::vector<glTFNode*> nodes = {};
    /// An array of samplers.
    std::vector<glTFSampler*> samplers = {};
    /// The index of the default scene.
    glTFid<glTFScene> scene = {};
    /// An array of scenes.
    std::vector<glTFScene*> scenes = {};
    /// An array of skins.
    std::vector<glTFSkin*> skins = {};
    /// An array of textures.
    std::vector<glTFTexture*> textures = {};

    // access functions -------------
    /// typed access for accessors
    glTFAccessor* get(const glTFid<glTFAccessor>& id) const {
        if (!id) return nullptr;
        return accessors.at((int)id);
    }
    /// typed access for animations
    glTFAnimation* get(const glTFid<glTFAnimation>& id) const {
        if (!id) return nullptr;
        return animations.at((int)id);
    }
    /// typed access for bufferViews
    glTFBufferView* get(const glTFid<glTFBufferView>& id) const {
        if (!id) return nullptr;
        return bufferViews.at((int)id);
    }
    /// typed access for buffers
    glTFBuffer* get(const glTFid<glTFBuffer>& id) const {
        if (!id) return nullptr;
        return buffers.at((int)id);
    }
    /// typed access for cameras
    glTFCamera* get(const glTFid<glTFCamera>& id) const {
        if (!id) return nullptr;
        return cameras.at((int)id);
    }
    /// typed access for images
    glTFImage* get(const glTFid<glTFImage>& id) const {
        if (!id) return nullptr;
        return images.at((int)id);
    }
    /// typed access for materials
    glTFMaterial* get(const glTFid<glTFMaterial>& id) const {
        if (!id) return nullptr;
        return materials.at((int)id);
    }
    /// typed access for meshes
    glTFMesh* get(const glTFid<glTFMesh>& id) const {
        if (!id) return nullptr;
        return meshes.at((int)id);
    }
    /// typed access for nodes
    glTFNode* get(const glTFid<glTFNode>& id) const {
        if (!id) return nullptr;
        return nodes.at((int)id);
    }
    /// typed access for samplers
    glTFSampler* get(const glTFid<glTFSampler>& id) const {
        if (!id) return nullptr;
        return samplers.at((int)id);
    }
    /// typed access for scenes
    glTFScene* get(const glTFid<glTFScene>& id) const {
        if (!id) return nullptr;
        return scenes.at((int)id);
    }
    /// typed access for skins
    glTFSkin* get(const glTFid<glTFSkin>& id) const {
        if (!id) return nullptr;
        return skins.at((int)id);
    }
    /// typed access for textures
    glTFTexture* get(const glTFid<glTFTexture>& id) const {
        if (!id) return nullptr;
        return textures.at((int)id);
    }

    /// destructor
    ~glTF() {
        for (auto e : accessors)
            if (e) delete e;
        for (auto e : animations)
            if (e) delete e;
        if (asset) delete asset;
        for (auto e : bufferViews)
            if (e) delete e;
        for (auto e : buffers)
            if (e) delete e;
        for (auto e : cameras)
            if (e) delete e;
        for (auto e : images)
            if (e) delete e;
        for (auto e : materials)
            if (e) delete e;
        for (auto e : meshes)
            if (e) delete e;
        for (auto e : nodes)
            if (e) delete e;
        for (auto e : samplers)
            if (e) delete e;
        for (auto e : scenes)
            if (e) delete e;
        for (auto e : skins)
            if (e) delete e;
        for (auto e : textures)
            if (e) delete e;
    }
};

// #codegen end type
// -----------------------------------------------------------

///
/// Loads a gltf file from disk
///
/// - Parameters:
///     - filename: scene filename
///     - load_bin/load_img: load binary data
///     - skip_missing: do not throw an exception if a file is missing
/// - Returns:
///     - gltf data loaded (nullptr on error)
///
glTF* load_gltf(const std::string& filename, bool load_bin = true,
    bool load_img = false, bool skip_missing = false);

///
/// Loads a binary gltf file from disk
///
/// - Parameters:
///     - filename: scene filename
///     - other params as above
/// - Returns:
///     - gltf data loaded (nullptr on error)
///
glTF* load_binary_gltf(const std::string& filename, bool load_bin = true,
    bool load_img = false, bool skip_missing = false);

///
/// Saves a scene to disk
///
/// - Parameters:
///     - filename: scene filename
///     - gltf: data to save
///     - save_bin/save_images: save binary data
///
void save_gltf(const std::string& filename, const glTF* gltf,
    bool save_bin = true, bool save_images = false);

///
/// Saves a scene to disk
///
/// - Parameters:
///     - filename: scene filename
///     - gltf: data to save
///     - save_bin/save_images: save binary data
///
void save_binary_gltf(const std::string& filename, const glTF* gltf,
    bool save_bin = true, bool save_images = false);

///
/// Load buffer data.
///
/// - Parameters:
///     - dirname: directory used to resolve path references
///     - skip_missing: do not throw an exception if a file is missing
/// - Out Parameters:
///     - gltf: data to data
/// - Returns:
///     - whether an error occurred
///
void load_buffers(
    glTF* gltf, const std::string& dirname, bool skip_missing = false);

///
/// Loads images.
///
/// - Parameters:
///     - dirname: directory used to resolve path references
///     - skip_missing: do not throw an exception if a file is missing
///     - err: if set, store error message on error
/// - Out Parameters:
///     - gltf: data to data
/// - Returns:
///     - whether an error occurred
///
void load_images(
    glTF* asset, const std::string& dirname, bool skip_missing = false);

///
/// Save buffer data.
///
/// - Parameters:
///     - dirname: directory used to resolve path references
///     - gltf: data to save
///     - skip_missing: do not throw an exception if a file is missing
///
void save_buffers(
    const glTF* gltf, const std::string& dirname, bool skip_missing);

///
/// Saves images.
///
/// - Parameters:
///     - dirname: directory used to resolve path references
///     - gltf: data to save
///     - skip_missing: do not throw an exception if a file is missing
///
void save_images(
    const glTF* asset, const std::string& dirname, bool skip_missing);

///
/// Convert a gltf asset to flattened group of scene.
///
scene_group* gltf_to_scenes(const glTF* gltf, int scene_idx = -1);

///
/// Convert a flattened group of scene into a gltf. If separate_buffers,
/// creates a separate buffer for each each and animation and
/// prepend buffer_uri to its name.
///
glTF* scenes_to_gltf(const scene_group* fl_gltf, const std::string& buffer_uri,
    bool separate_buffers = false);

///
/// Validate a gltf. Missing many validation as of this version.
///
std::vector<std::pair<std::string, std::string>> validate_gltf(
    const glTF* gltf);

///
/// Computes the local node transform and its inverse.
///
ym::mat4f node_transform(const glTFNode* node);

///
/// A view for gltf array buffers that allows for typed access.
///
struct accessor_view {
    /// construct a view from an accessor
    accessor_view(const glTF* gltf, const glTFAccessor* accessor);

    /// number of elements in the view
    int size() const { return _size; }
    /// number of elements in the view
    int count() const { return _size; }
    /// number of components per element
    int ncomp() const { return _ncomp; }
    /// check whether the view is valid
    bool valid() const { return _valid; }

    /// get the idx-th element of fixed length width default values
    template <int N>
    ym::vec<float, N> getv(int idx, const ym::vec<float, N>& def) const {
        auto v = def;
        for (auto i = 0; i < std::min(_ncomp, N); i++) v[i] = get(idx, i);
        return v;
    }
    /// get the idx-th element of fixed length
    template <int N>
    ym::vec<float, N> getv(int idx) const {
        return getv(idx, ym::vec<float, N>());
    }

    /// get the idx-th element of fixed length as a matrix
    template <int N, int M>
    ym::mat<float, N, M> getm(int idx) const {
        auto v = ym::mat<float, N, M>();
        assert(_ncomp == N * M);
        for (auto j = 0; j < M; j++)
            for (auto i = 0; i < N; i++) v[j][i] = get(idx, j * N + i);
        return v;
    }

    /// get the c-th component of the idx-th element
    float get(int idx, int c = 0) const;

    /// get the idx-th element as integer with fixed length
    template <int N>
    ym::vec<int, N> getiv(int idx, const ym::vec<int, N>& def) const {
        auto v = def;
        for (auto i = 0; i < std::min(_ncomp, N); i++) { v[i] = geti(idx, i); }
        return v;
    }
    /// get the idx-th element as integer
    template <int N>
    ym::vec<int, N> getiv(int idx) const {
        return getiv(idx, ym::vec<int, N>());
    }

    /// get the c-th component of the idx-th element as integer
    int geti(int idx, int c = 0) const;

   private:
    const unsigned char* _data = nullptr;
    int _size = 0;
    int _stride = 0;
    int _ncomp = 0;
    glTFAccessorComponentType _ctype;
    bool _normalize = false;
    bool _valid = false;

    static int _num_components(glTFAccessorType type);
    static int _ctype_size(glTFAccessorComponentType componentType);
};

}  // namespace ygltf

#endif
